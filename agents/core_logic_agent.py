"""
Core Logic Agent - Writes Python code according to architecture
"""

import os
import json
from typing import Dict, Any, List, Optional
from .base_agent import BaseAgent

class CoreLogicAgent(BaseAgent):
    """Agent responsible for writing Python code"""
    
    def __init__(self):
        super().__init__(
            agent_id="core_001",
            name="Core Logic Agent",
            description="Writes Python code according to architecture specifications"
        )
        self.generated_files = []
    
    def execute(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """Execute code generation"""
        try:
            self.log_action("Starting code generation")
            
            # Load architecture
            architecture = self._load_architecture()
            if not architecture:
                return self.create_response(
                    False,
                    "No architecture found. Cannot generate code."
                )
            
            # Generate code for each module
            generated_files = []
            for module in architecture.get("modules", []):
                file_path = self._generate_module_code(module)
                if file_path:
                    generated_files.append(file_path)
            
            # Create main application file
            main_file = self._create_main_application()
            if main_file:
                generated_files.append(main_file)
            
            self.generated_files = generated_files
            self.log_action("Code generation completed")
            
            return self.create_response(
                True,
                "ðŸ§  Core logic written successfully",
                {"generated_files": generated_files}
            )
            
        except Exception as e:
            self.logger.error(f"Code generation failed: {str(e)}")
            return self.create_response(False, f"Code generation failed: {str(e)}")
    
    def _load_architecture(self) -> Optional[Dict[str, Any]]:
        """Load architecture from file"""
        try:
            with open("project_docs/architecture.json", "r") as f:
                return json.load(f)
        except FileNotFoundError:
            self.logger.error("Architecture file not found")
            return None
        except json.JSONDecodeError as e:
            self.logger.error(f"Invalid architecture file: {e}")
            return None
    
    def _generate_module_code(self, module: Dict[str, Any]) -> Optional[str]:
        """Generate code for a specific module"""
        try:
            module_name = module.get("name", "unknown_module")
            file_path = f"src/{module_name.lower().replace(' ', '_')}.py"
            
            # Create src directory if it doesn't exist
            os.makedirs("src", exist_ok=True)
            
            # Generate code using LLM
            code = self._generate_code_with_llm(module)
            
            # Write code to file
            with open(file_path, "w") as f:
                f.write(code)
            
            self.logger.info(f"Generated code for {module_name}: {file_path}")
            return file_path
            
        except Exception as e:
            self.logger.error(f"Failed to generate code for module {module.get('name', 'unknown')}: {str(e)}")
            return None
    
    def _create_main_application(self) -> str:
        """Create a main application file that ties everything together"""
        try:
            main_code = '''"""
Main Application Entry Point
Auto-generated by AI Agent Ecosystem Builder
"""

import sys
import os
import logging
from datetime import datetime
from pathlib import Path

# Add current directory to path for imports
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

def setup_logging():
    """Setup logging configuration"""
    # Create logs directory if it doesn't exist
    logs_dir = Path("logs")
    logs_dir.mkdir(exist_ok=True)
    
    # Create timestamped log file
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    log_file = logs_dir / f"application_{timestamp}.log"
    
    # Configure logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file, encoding='utf-8'),
            logging.StreamHandler(sys.stdout)
        ]
    )
    
    logger = logging.getLogger(__name__)
    logger.info(f"Logging initialized. Log file: {log_file}")
    return logger

def main():
    """Main application function"""
    # Setup logging
    logger = setup_logging()
    
    logger.info("ROCKET: Starting AI-generated Python application")
    logger.info("=" * 50)
    
    try:
        # Import and run your application modules here
        # This is where you would import your generated modules
        
        logger.info("FOLDER: Application modules loaded successfully")
        logger.info("TOOLS: Customize this main.py file to integrate your generated modules")
        
        # Example of how to use generated modules:
        # from your_module import YourClass
        # app = YourClass()
        # app.run()
        
        logger.info("SUCCESS: Application ready to use!")
        
    except Exception as e:
        logger.error(f"ERROR: Error running application: {e}")
        logger.exception("Full traceback:")
        return 1
    
    logger.info("SUCCESS: Application completed successfully")
    return 0

if __name__ == "__main__":
    sys.exit(main())
'''
            
            main_path = "src/main.py"
            with open(main_path, "w") as f:
                f.write(main_code)
            
            self.logger.info(f"Created main application file: {main_path}")
            return main_path
            
        except Exception as e:
            self.logger.error(f"Failed to create main application: {str(e)}")
            return None
    
    def _generate_code_with_llm(self, module: Dict[str, Any]) -> str:
        """Generate code using LLM"""
        try:
            messages = [
                {
                    "role": "system",
                    "content": """You are a Python developer. Generate clean, well-structured Python code based on the module specification. Follow these guidelines:

1. Use proper Python conventions (PEP 8)
2. Include comprehensive docstrings
3. Add type hints
4. Include error handling
5. Write clean, readable code
6. Include example usage if applicable

Return only the Python code, no explanations."""
                },
                {
                    "role": "user",
                    "content": f"Generate Python code for module: {json.dumps(module, indent=2)}"
                }
            ]
            
            response = self.call_llm(messages)
            
            # Clean up response to ensure it's valid Python
            code = self._clean_code_response(response)
            return code
            
        except Exception as e:
            self.logger.error(f"LLM code generation failed: {str(e)}")
            raise
    
    def _clean_code_response(self, response: str) -> str:
        """Clean up LLM response to ensure valid Python"""
        lines = response.split('\n')
        cleaned_lines = []
        
        # Remove markdown code blocks if present
        in_code_block = False
        for line in lines:
            if line.strip().startswith('```'):
                in_code_block = not in_code_block
                continue
            if not in_code_block and line.strip():
                cleaned_lines.append(line)
        
        return '\n'.join(cleaned_lines)
    
    def get_generated_files(self) -> List[str]:
        """Get list of generated files"""
        return self.generated_files
    
    def validate_generated_code(self) -> Dict[str, Any]:
        """Validate generated code"""
        validation_results = {}
        
        for file_path in self.generated_files:
            try:
                # Basic syntax validation
                with open(file_path, 'r') as f:
                    code = f.read()
                
                # Try to compile the code
                compile(code, file_path, 'exec')
                validation_results[file_path] = {"syntax_valid": True}
                
            except SyntaxError as e:
                validation_results[file_path] = {
                    "syntax_valid": False,
                    "error": str(e)
                }
            except Exception as e:
                validation_results[file_path] = {
                    "syntax_valid": False,
                    "error": f"Unexpected error: {str(e)}"
                }
        
        return validation_results
